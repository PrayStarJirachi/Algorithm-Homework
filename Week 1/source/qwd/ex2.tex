Here is the python code:

\pythoncode{source/qwd/ex2.py}

Since we use dynamic programing, the runing time depends on how many binomial coefficients we calculate.
Consider the formula
\[\binom{n}{k}=\binom{n-1}{k-1}+\binom{n-1}{k}\]
It's easy to see that the area we calculate is an parallelogram in Pascal's triangle.
More specificly, in order to get the answer of $\binom{n}{k}$, there are exactly $n-k+1$ numbers we calculate in the columns from $1$ to $k$,
so we need to do $k\cdot (n-k+1)$ additions.\par
The time we need for a single addition depends on the length of the result, namely $\log \binom{n}{k}$.
%Since
%\[\sum \binom{n}{k}=2^n\]
%We can easily see that $\binom{n}{k}$ has a length up to $n$.
So the upper bound of the running time is $O(\log \binom{n}{k}\cdot k\cdot (n-k+1))$. If we consider addition as $O(1)$, we get a lower bound: $O(k\cdot (n-k+1))$.
The input size is $O(\log n)$ and the output size is $O(\log \binom{n}{k})$. As you can see, it is not an efficient algorithm but much better than the one in Exercise1.

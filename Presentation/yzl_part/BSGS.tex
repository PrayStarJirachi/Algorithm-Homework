\documentclass{beamer}
\usetheme{Warsaw}
\usepackage{CJK}
\newtheorem{mytht}{∂®¿Ì}[section]
\begin{document}
\begin{CJK}{GBK}{kai}
\title{Discrete Logarithm}
\author{Lucas}
\institute{Shanghai Jiao Tong University}
\date{\today{}}
\begin{frame}
\titlepage
\end{frame}
\begin{frame}
\frametitle{Problem}
Find a smallest non-negative number $x$ satisfying

\[A^x = B\,\,(mod\,\,P)\]

which $P$ is a prime, $A, B \in [0, P)$.
\end{frame}
\begin{frame}
\frametitle{Naive Approach}
According to Fermat Theory, when $A, P$ is coprime, we have: 

\[A^{P} = A\,\,(mod\,\,P)\]

the only special case is $A = 0$, and in this case, $B$ must be zero.

\bigskip
For $A \neq 0$, we can just iterate $x$ from 0 to $P - 1$ checking if $A^x = B\,\,(mod\,\,P)$.
the complexity is $O(P)$.


\end{frame}
\begin{frame}
\frametitle{Yet Another Naive Algorithm}
We mapped $A^{x} \rightarrow x, x \in [0, P - 1)$ by using a Hash-Table.

\bigskip
For finding $B$, we just need to query $B$ in this Hash-Table, which only requires $O(1)$ time.

\bigskip
Preparing the Hash-Table needs $O(P)$ time, which the total complexity is $O(P + 1) = O(P)$.
\end{frame}

\begin{frame}
\frametitle{Balanced Programming}
\begin{itemize}
\item First we choose a number $S \in [1, P - 1]$.
\item We mapped $A^{x} \rightarrow x, x \in [0, S)$ by using a Hash-Table.
\item Calculate $A^{-S}$ by using Fast Exponentiation.
\end{itemize}

\bigskip
In this step, we needs $S + \log P$ operations.
\end{frame}

\begin{frame}
\frametitle{Balanced Programming}
$x$ can be represented as $i\times S + j$, we can transform the equation:

\[A^{i\times S + j} = B \Leftrightarrow A^{j} = B \times (A^{-S})^{i}\,\,(mod\,\,P)\]

which $j \in [0, S)$, and $i \leq \frac{P}{S}$.

\bigskip
We can just iterate $i$ from 0 to $\frac{P}{S}$ checking if $B \times (A^{-S})^{i}$ is in Hash-Table. In worst occasion, we need to iterator $\frac{P}{S} + 1$ times.
\end{frame}

\begin{frame}
\frametitle{Total complexity evaluation}
As you can see, the total operations we need to do is 

\[S + \log P + \frac{P}{S} + 1\]

we want to choose $S$ optimally to have the best total complexity.

\bigskip
when $S = \sqrt{P}$, the total operations is:

\[S + \log P + \frac{P}{S} + 1 = 2\sqrt{P} + \log P + 1 = O(\sqrt{P})\]

thus we get a $O(\sqrt{P})$ algorithm by choosing $S$ optimally.
\end{frame}
\end{CJK}
\end{document}
